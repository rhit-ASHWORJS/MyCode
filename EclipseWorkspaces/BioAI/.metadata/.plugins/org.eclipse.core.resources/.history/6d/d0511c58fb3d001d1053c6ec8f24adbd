import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class FeedForwardNeuralNet implements Comparable<FeedForwardNeuralNet>{
	double[][] networkWeights;
	double[] thresholds;
	int inputNodes;
	int outputNodes;
	public static HashMap<double[],double[]> functionData;
	
	public FeedForwardNeuralNet(double[][] networkWeights, double[] thresholds, int inputNodes, int outputNodes)
	{
		this.networkWeights = networkWeights;
		if(networkWeights.length != networkWeights[0].length)
		{
			System.err.println("FFNN declared with non-square matrix");
			this.networkWeights = null;
		}
		this.thresholds = thresholds;
		this.inputNodes = inputNodes;
		this.outputNodes = outputNodes;
	}
	
	public FeedForwardNeuralNet(int numNodes, int inputs, int outputs)
	{
		if(numNodes < inputs+outputs)
		{
			System.err.println("Can't have more inputs/outputs than nodes in a neural net");
		}
		this.networkWeights = new double[numNodes][numNodes];
		for(int i=0; i<numNodes; i++)
		{
			for(int j=i+1; j<numNodes; j++)
			{
				networkWeights[i][j] = SeededRandom.rnd.nextDouble(Constants.MAXEDGEWEIGHT*2)-Constants.MAXEDGEWEIGHT;
			}
		}
		this.thresholds = new double[numNodes];
		for(int i=0; i<numNodes; i++)
		{
			thresholds[i]=SeededRandom.rnd.nextDouble(Constants.MAXNODETHRESHOLD*2)-Constants.MAXNODETHRESHOLD;
		}
		
		this.inputNodes = inputs;
		this.outputNodes = outputs;
	}
	
//	public boolean followsRules() {
//		
//	}
	
	public double[] runNeuralNetwork(double[] inputs)
	{
		if(inputs.length != inputNodes)
		{
			System.err.println("Wrong number of inputs to neural network.  Expected " +inputNodes + " but got "+inputs.length);
			return null;
		}
		
		double[] nodeValues = new double[networkWeights.length];
		for(int input=0; input<inputNodes; input++)
		{
			nodeValues[input] = inputs[input];
		}
		
		for(int workingNode=inputNodes; workingNode < networkWeights.length; workingNode++)
		{
			int sumOfInputs = 0;
			for(int otherNode=0; otherNode<workingNode; otherNode++)
			{
				if(nodeValues[otherNode] != 0)
				{
					sumOfInputs += nodeValues[otherNode]*networkWeights[otherNode][workingNode];
				}
			}
			if(sumOfInputs >= thresholds[workingNode])
			{
				nodeValues[workingNode] = 1;
			}
			else
			{
				nodeValues[workingNode] = 0;
			}
		}
		
		double[] outputs = new double[outputNodes];
		for(int output = 0; output < outputNodes; output++)
		{
			outputs[output] = nodeValues[nodeValues.length-outputNodes+output];
		}
		return outputs;
	}
	
	public double getMSE(HashMap<double[], double[]> desired)
	{
		double sumSquareDifferences = 0;
		for(double[] input : desired.keySet())
		{
			double[] neuralOutput = this.runNeuralNetwork(input);
			for(int output=0; output<neuralOutput.length; output++)
			{
				double difference = neuralOutput[output] - desired.get(input)[output];
				sumSquareDifferences += Math.pow(difference, 2);
			}
		}
		return Math.sqrt(sumSquareDifferences);
	}
	
	public double getFitness(HashMap<double[], double[]> desired)
	{
		return 1/(1+getMSE(desired));
	}
	
	public double getFittness()
	{
		if(functionData == null)
		{
			System.out.println("Please initialize test data");
			return -1;
		}
		return getFitness(functionData);
	}
	
	public void printTruthTable01()
	{
		System.out.println("Truth table for test neural network");
		double[] input = new double[inputNodes];
		
		for(int inputNum=0; inputNum<Math.pow(2, inputNodes); inputNum++)
		{
			//setup input array using overly complex math because I want to
			int testInputNum = inputNum;
			int i = 0;
			for(int test=(int) Math.pow(2, inputNodes-1); test>=1; test/=2)
			{
				if(testInputNum >= test)
				{
					testInputNum -= test;
					input[input.length-1-i]=1;
				}
				else
				{
					input[input.length-1-i]=0;
				}
				i++;
			}
			
			//now run our test
			System.out.println(Arrays.toString(input)+":"+Arrays.toString(runNeuralNetwork(input)));
		}
	}
	
	@Override
	public int compareTo(FeedForwardNeuralNet o) {
		if(functionData == null)
		{
			System.out.println("Sorting function not set in FeedForwardNeuralNetwork class");
			return 0;
		}
		else
		{
			if(this.getFitness(functionData) > o.getFitness(functionData))
			{
				return 1;
			}
			if(this.getFitness(functionData) == o.getFitness(functionData))
			{
				return 0;
			}
			else
			{
				return -1;
			}
		}
	}
}
