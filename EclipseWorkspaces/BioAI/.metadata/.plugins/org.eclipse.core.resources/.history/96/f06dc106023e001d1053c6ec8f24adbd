import java.util.ArrayList;

public class FFNNPopulation {

	public static final int numInitial = Constants.POPULATIONSIZE;
	ArrayList<FeedForwardNeuralNet> networks = new ArrayList<FeedForwardNeuralNet>();
	
	public TreePopulation()
	{
		int numGrowPerDepth = numGrowInitial/maxDepth;
		int numFullPerDepth = numFullInitial/maxDepth;
		
		for(int depth=1; depth<=maxDepth; depth++)//starting at depth 1, again because of stage 3.1 specifications
		{
			for(int grow=0; grow<numGrowPerDepth; grow++)
			{
				trees.add(OpTree.randomGrowingTree(depth));
			}
			for(int full=0; full<numFullPerDepth; full++)
			{
				trees.add(OpTree.randomFullTree(depth));
			}
		}
		
		if(trees.size() != size)
		{
			System.out.println("Please check TreePopulation constructor, tree size and array size differ");
		}
	}
	
	public TreePopulation(ArrayList<OpTree> trees)
	{
		this.trees = trees;
	}
	
	public void sortTrees()
	{
		Collections.sort(trees);
		Collections.reverse(trees);//we want higher fitness first
	}
	
	public double getBestFitness()
	{
		sortTrees();
		return trees.get(0).getFitness();
	}
	
	public OpTree getOptreeRankSelection()//Using the tournament-based ranked selection described in one of the readings
	//Make sure you've called sorting before your run this, otherwise it is absolute nonsense.
	{
		int individual1 = SeededRandom.rnd.nextInt(trees.size());
		int individual2 = SeededRandom.rnd.nextInt(trees.size());
		
		if(individual1 < individual2)
		{
			return trees.get(individual1);
		}
		else
		{
			return trees.get(individual2);
		}
	}
	
	public static final double CROSSOVER_PROB = 0.9;
	public static final double SUBSTITUTION_PROB = 0.09;
	public static final double CLONING_PROB = 0.01;
	
	public TreePopulation getNextGeneration()
	{
		ArrayList<OpTree> nextGen = new ArrayList<OpTree>();
		sortTrees();
		//ELITISM LINE BELOW
//		nextGen.add(trees.get(0));
		//END ELITISM
		while(nextGen.size() < size)
		{
			double roll = SeededRandom.rnd.nextDouble(1);
			if(roll < CROSSOVER_PROB)
			{
				OpTree p1 = getOptreeRankSelection().clone();
				OpTree p2 = getOptreeRankSelection().clone();
				
				OpTree.recombine(p1, p2);
				
				if(nextGen.size() == size-1)
				{
					nextGen.add(p1);
				}
				else
				{
					nextGen.add(p1);
					nextGen.add(p2);
				}
			}
			else if(roll < CROSSOVER_PROB + SUBSTITUTION_PROB)
			{
				OpTree toMutate = getOptreeRankSelection().clone();
				OpTree.mutate(toMutate);
				nextGen.add(toMutate);
			}
			else if(roll <= CROSSOVER_PROB + SUBSTITUTION_PROB + CLONING_PROB)
			{
				nextGen.add(getOptreeRankSelection().clone());
			}
			else
			{
				System.out.println("nextgen error");
				return null;
			}
		}
		TreePopulation newPopulation = new TreePopulation(nextGen);
		return newPopulation;
	}
}
